{"git":[{"id":"0","parent":"__SOURCE__","internal":{"type":"Post","contentDigest":""},"children":[],"title":"게임 제작해보자 1","content":"\n## 게임을 제작해보자\n\n대학교 학기 중에 SW 동아리를 하게 되어 무언가를 제작해야하는 상황에 놓였었다. 짧은 시간동안 만들 수 있는게 녹록하지 않아 만들기 간단한 것으로 고민하던 중에 T-REX Dino라는 게임이 떠 올랐다.\n10월 14일 부터 11월 25일까지의 아주 짧은 기간이라 무언가를 만들려면 최대한 빠르게 만들어야 했다. 그래서 T-REX Dino 게임 적합하다고 생각해서 바로 만들기 시작했다. 만드는 것도 중요하긴 하지만 이것저것 보면서 게임을 제작할 때 계획하는 것이 중요하다는 것을 알고 있었기에 간단하게 계획을 하고 만들기 시작했다. 프로그램을 제작하기 전에 간단하게 짠 것을 모식화면 다음과 같이 만들 수 있다.\n\n- 장애물 관리자\n  - 장애물 관리자 생성\n  - 장애물 관리자 삭제\n  - 장애물 관리자 초기화(게임 재시작 시)\n- 장애물\n  - 생성\n- 캐릭터 \n  - 출력\n  - 움직임\n- 텍스쳐 관리자\n  - 출력\n\n제작할 언어는 c언어와 [raylib](https://www.raylib.com/)를 사용해서 제작할 예정이다. 사실 동아리 활동이 이번 2학기만 이뤄진 것이 아닌 지난 1학기도 동아리 활동을 하였다. 하지만 2학년인 제일 바쁜 시간으로 과제와 기간이 겹쳐 하지 못하였기 때문에 1학기의 연장선으로 1학기때 사용하던 [raylib](https://www.raylib.com/)를 사용하여 제작하고자 하였다. \n\n본격적으로 구현하는 파트로 넘어와서 가장 먼저 제작할 것은 `텍스쳐 관리자`와 `장애물 관리자`, `장애물`가 아닌 캐릭터 움직을 재현하는게 우선이라고 생각했다. 움직임을 구현하기 가장 쉬운 방식은 캐릭터 앞으로 직접 움직이는 것이 아닌, 뒤의 배경과 장애물이 움직이면서 `플레이어`가 움직이는 것 \"처럼\" 보이게 하는 방식을 사용했다. `플레이어`를 만들면서 편리하게 수정하고 관리할 수 있도록 객체처럼 사용하는 것을 원했기에 구조체에 함수 포인터를 넣어서 사용하였다. 구조체 안에 가장 먼저 `aabb`[^1] 와 화면의 사이즈 저장하는 변수와 기본 플레이어의 위치를 저장하는 `idle_pos`를 만들어 주었다. \n\n객체처럼 사용한다고 하였으니 표시 함수에 대한 함수 포인터 지정을 해야한다. 그렇기에 초반에 구조체를 설계할 때 다음과 같이 설계하였다.(현재는 구조체가 많이 바뀌었다.)\n```c\n// player.h\ntypedef struct Player{\n    Rectangle aabb;\n    Vector2 idle_pos;\n    Vector2 velocity;\n    bool isJump;\n    void (*move)(struct Player * p);\n    void (*show)(struct Player * p);\n}Player;\n```\n이렇게 선언 한 후에 \n\n```c\nvoid DrawPlayer(Player *player) {\n    player_move(player);\n    ApplyGravity(player);\n    DrawRectangleRec(player->aabb, RED);\n}\n```\n`플레이어`의 출력과 관련된 함수를 제작한 후 플레이어 생성에 관련된 함수안에서 포인터 함수와 연결해주었다.\n\n```c\nPlayer * create(float x_size, float y_size){\n    ...\n    p->show = DrawPlayer;\n    ...\n}\n```\n\n`플레이어`의 움직임은 점프만 구현하면 되기 때문에 매우 간단하다. 움직임도 학교에서 간단히 배운 가속도와 속도 거리에 관련된 공식만 알면 간단하게 구현할 수 있는 내용이다.\n\n```c\nvoid ApplyGravity(Player *player) {\n    if (player->aabb.y < player->idle_pos.y) //점프 상태\n        player->velocity.y += GRAVITY; //중력 가속도 넣어준다.\n\n    const double deltaTime = GetFrameTime();\n\n    player->aabb.y += player->velocity.y * deltaTime; //넓이 값 구한다.\n}\n```\n이렇게 간단하게 구현이 되지만 추후에 이 함수 때문에 엄청 고생한다...\n\n[^1]: 막 지은것 같지만 실제로 `Axis Aligned Bounding Box`라고 불리는 녀석이다.\n","tags":["python","c","raylib","DQN","c99","C99","shmem","gamedev","game-dev","shared-memory"],"dates":["2022-11-13T16:43:23Z","2022-11-13T15:52:18Z"]},{"id":"1","parent":"__SOURCE__","internal":{"type":"Post","contentDigest":""},"children":[],"title":"testingPurpose","content":"","dates":["2022-02-27T13:03:00Z","2022-02-27T13:00:04Z","2022-02-27T12:59:53Z","2022-02-24T16:12:01Z"]},{"id":"2","parent":"__SOURCE__","internal":{"type":"Post","contentDigest":""},"children":[],"title":"역전파에 대해서 공부한 뒤","content":"\n이 글을 쓰는 이유는 내가 알잘딱딸센으로 이야기한 역전파에 대한 이야기이다.\n\n물론 틀린 내용도 있겠지만, 그래도 내가 역전파를 공부하면서 쾌변한 느낌을 받았던 방식이다.\n(틀린 것이 있다면 자유롭게 이야기 부탁드립니다.)\n\n우선 미분 대한 이야기를 하고 넘어가야된다고 생각한다.\n미분이란 뭘까?\n> 사실 나도 그딴거 잘 모른다.\n\n고등학교 때 수학 푸는 것에 대한 관심이 없었고, 단지 이론만 듣는 것을 좋아했던 나에게는 미분이란 단지 극점을 구하는 방식으로만 알고 있다.\n물론 추가적인 내용들이 더 있겠지만, 나에게는 그렇게 다가왔고 지금도 그렇게 기억하고 있다.\n\n극점 혹은 도함수의 그래프의 함수값이 0인 지점을 의미하지만 나는 역전파를 공부하면서 살짝 바꾸어 이해하였다.\n\n극점을 어느 특정 함수의 최저값으로 이해를 하고 쭉 봤더니 이해하기 쉬워서 그렇게 했다.\n\n그러면 왜 미분을 이야기했냐? \n\n역전파라는 것은 결국 인공지능 혹은 딥러닝한 모델이 결과를 도출한 값과 실제 값의 차를 줄여나가는 과정이기 때문이다.\n생각을 해보면 당연한 이야기이다. 실제 값과 가까워 질 수록 그에 대한 차는 점점 작아져서 0에 근접할 것이다.( 무한대로 가면 0으로 수렴히지만 컴퓨터의 한계와 기간의 한계로 0에 근접하게 된다.)\n\n그렇기 때문에 에러 함수에 대해 미분을 하여 최소값으로 항하는 값을 구하는 것이다.\n\n여기서 에러 함수와 다양한 이야기를 더 하고 넘어가야 한다. \n\n에러 함수는 딥러닝 모델 혹은 퍼셉트론 모델이 도출한 결과와 실제값의 차를 함수로 도출하는 함수이다.\n\n$$\nE = \\sum_j{1 \\over 2}(t_j - o_i)^2\n$$\n\n이게 에러함수의 모습이다. \n\n$t_j$는 실제 값을 $o_j$는 모델에서 도출한 결과 값이다.\n\n여기서 우리가 봐야할 사실은 $o_j$의 값을 제외하고 다 아는 값이라는 것이다. \n이 사실을 기억해 두고 넘어가보자\n\n2번째는 활성화 함수이다.\n활성화 함수도 정말 다양하게 많은 함수들이 존재하지만 결국 사용하는 함수가 정해져 있고 가장 대표적인 함수 sigmoid를 보면\n\n$$\no_j = {1 \\over (1 - e^{-net_j}))}\n$$\n\n의 형태를 띄기에 마찬가지로 $o_j$를 $f(x)$로 바꿔서 본다면 결국 이 또한 모르는 미지수는 $net_j$으로 되기 때문이다.\n","tags":["deep","learning"],"dates":["2023-06-05T12:34:27Z","2023-06-05T09:07:05Z"]},{"id":"3","parent":"__SOURCE__","internal":{"type":"Post","contentDigest":""},"children":[],"title":"백준 1005번 문제 해결 과정","content":"\n\n--//\n..first link{+first+}\n..second link{+second+}\n..third link{+third+}\n//--\n\n\n여러 문제를 풀어보기도 하고 어려가지를 이미 해보았지만... solved.ac에서 처음으로 골드 문제를 한번 풀어 보았다. 좀 호기롭게 했는데, 결과가 너무 처참했다...\n\n사실 1001번 부터 계속 풀어왔고 번호 순서대로 풀어보려고 하였다.(하지만 내가 한 이행동이 얼마나 정신나간 짓인지 깨닫게 되었다.)\n\n처음 해결 과정을 어떻게 해서 시도 해봤는지에 대해서 먼저 설명하고 다른것들도 설명해보도록하겠다.\n\n사실 나는 순서가 정해져있는지 알았다.\n\n시작을 1로 해서 계속 숫자가 증가해 나가는 형식인 것으로 알고 있었다.\n\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/baekjoon1005/image1.jpg?raw=true)\n\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/baekjoon1005/image3.jpg?raw=true)\n우선 간단하게 설명을 해보도록 노력을 하겠지만 잘 할 수 있을지는 미지수긴 하다.\n\n앞서 위에서 이야기했듯 필자는 첫 정점 노드가 __무조건 1__ 인줄 알았다.\n\n그래서 이렇게 생각하였다. \n\n처음에 주어지는 가장 건축 시간을 저장해두고 그 노드의 간선에 따라 주어진 건축 시간을 더해 나간 후에 입력 마지막 줄에 주어지는 노드 위치를 출력시 자동으로\n출력이 되게 하는 방법이 좋을 것 같았다.\n\n그리고 여러개의 간선들이 모이는 노드일 경우에는 가장 큰 값으로 저장해두어서 2개 이상의 건축물들이 다 만들어지는 시간이 되게 해주었다.\n\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/baekjoon1005/image2.jpg?raw=true)\n\n그래서 나온 코드가 이렇게 된 코드다.\n\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct \n{\n    int * totalTime;\n    int count;\n}curentTime;\n\nvoid main(){\n    int repeatCount;            //첫줄 -> 반복되는 총 횟수\n    int buildCount,buildRule;   // 입력 두번째 줄 -> 건물 개수, 건물 건설 순서 개수\n    curentTime times[1001];     // 현재 건축물의 총 건축시간\n    int buildDelay[1001];       // 각각의 건축물의 건축시간\n    int buildDuration;          //건축시간 입력 임시 변수\n    int beforeBuild, afterBuild;//건축 순서 입력 임시 변수\n    int startPoint;             //원하는 건축물의 총 시간\n\n    int longest = 0,node; \n    scanf(\"%d\",&repeatCount);   //총 횟수를 받아온다.\n    for(int repeat = 0; repeat < repeatCount; repeat++){\n        scanf(\"%d %d\",&buildCount,&buildRule); //두번째 줄 입력\n        for(int i = 0;i<buildCount;i++){\n            scanf(\"%d\",&buildDuration); //건축 시간 입력 buildCount번만큼 반복\n            buildDelay[i] = buildDuration; //\n            times[i].count = 0; //구조체의 totalTime의 길이 데이터이다\n        }\n        for(int i = 0;i<buildRule;i++){\n            scanf(\"%d %d\",&beforeBuild,&afterBuild);\n            beforeBuild--; //index시작이 0인것을 감안하여 1을 뺴준다.\n            afterBuild--;\n            if(times[beforeBuild].count == 0){ //time첫 읽으시에 동적할당 첫 초기화\n                //이전 빌딩에 대한 정보를 넣게 위에 사용함 그리고 재 선언 방지를 위해 count가 0일때만 실행\n                times[beforeBuild].totalTime = (int *)malloc(sizeof(int)*(++times[beforeBuild].count));\n                //이전 빌딩에 건축이 다만들어지는 시간(이하: 건축시간)을 저장\n                times[beforeBuild].totalTime[times[beforeBuild].count - 1] = buildDelay[beforeBuild]; \n            }\n            \n            if(times[afterBuild].count == 0) //이후 빌딩에 대한 정보가 없을 경우(array count가 0일 경우)에 실행한다.\n                //이후 빌딩의 건축시간을 저장\n                times[afterBuild].totalTime = (int *)malloc(sizeof(int)*(++times[afterBuild].count)); \n            else\n                //이미 동적할당이 배정이 되어있는 상태라면 재배정을 통한 크기 확충및 데이터 저장\n                times[afterBuild].totalTime = (int *)realloc(times[afterBuild].totalTime,sizeof(int)*(++times[afterBuild].count)); \n            //여기서는 하나의 노드에서 2개 이상을 받을 수 있었기에 계속 추가 가능한 형태로 만들어 주었다.\n            times[afterBuild].totalTime[times[afterBuild].count - 1] = buildDelay[afterBuild];\n            //임시로 만드는 변수이다. 이변수는 노드가 2개이상인 경우에 가능 오래 걸리는 시간을 저장한다.\n            int tempBiggest = 0; \n            for(int i = 0; i < times[beforeBuild].count;i++){\n                if(tempBiggest < times[beforeBuild].totalTime[i])\n                    tempBiggest = times[beforeBuild].totalTime[i];\n            }\n            //가장 오래걸리는 시간을 이후 빌딩 건축시간에 더하여 총 건축시간을 만든다.\n            times[afterBuild].totalTime[times[afterBuild].count - 1] += tempBiggest;\n        }\n        //데이터가 원하는 위치의 인덱스 값을 받는다.\n        scanf(\"%d\",&startPoint);\n        int biggestResult = 0;\n        for(int i =0;i < times[startPoint - 1].count;i++){\n            if(biggestResult < times[startPoint - 1].totalTime[i])\n                biggestResult = times[startPoint - 1].totalTime[i];\n        }\n        //그 노드의 가장 큰 값을 출력한다.\n        printf(\"%d\\n\",biggestResult);\n    }\n    return 0;\n}\n```\n\n코드가 난잡하다 이쁘지 않다... 주석 처리도 안되어있어서 다시 읽어가면서 해석했다... 주석 다는 것에 대한 습관을 반드시 길러놓자...\n\n이렇게 만들어서 잘 될 줄 알았지만 나온 결과물은..... 런타임 에러... 될 줄 알았지만 어림도 없다는 걸 알려주는 것인지 살짝 살짝 수정하였지만 4번이나 런타임 에러가 떠버렸다.\n\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/baekjoon1005/image4.png?raw=true)\n하하하;;;\n\n그래서 결국 찾아봤다.\n\n솔직히 마음이 양심에 찔렸다. 그래도 하루동안 고민하고 만들어봤다는것에 대해 위안을 삼고 찾아보니 **위상 정렬** 이라는 방식이 있다는 것을 깨달았다. \n\n그래서 블로그에있는 글들을 읽어봐도 솔직히 처음에는 이해는 했지만 코드로 어떻게 구상을 해야되는지 감이 잡히지 않았다.\n위상정렬 설명은 아래 블로그를 참고했다.\n\n[blog1]\n[blog2]\n뭐 한시간동안 고민좀 해보니깐 그래도 감이 잡힌거 같아서 나름대로 정리해서 올려보겠다.\n```\n8 8\n10 20 1 5 8 7 1 43\n1 2\n1 3\n2 4\n2 5\n3 6\n5 7\n6 7\n7 8\n7\n```\n우선 백준1005번에 있는 예시로 사용하도록하겠다. 찾는건 7까지이니깐 길이상 생략하고 하였다.\n\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/baekjoon1005/draw1.png?raw=true)\n\n우선 전개도로 나타내면 이렇게 나오게 된다. 그리고 각각의 선들이 몇번째의 칸으로 가게 되는지 기록하면 아래의 배열로 나오게된다.\n\n그리고 배열에서 0인 모든 노드를 찾아서 [큐]안에 넣어준다.\n0인 노드는 하나 밖에 없으니깐 큐에 0만 넣어주게 된다.\n그 후 노드0번이 어디로 향하는지 찾은 후 배열에서 목표 노드의 카운트를 하나씩 줄여준다.\n\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/baekjoon1005/draw2.png?raw=true)\n\n그리고 사용한 노드는 -1로 바꾸어 0인 노드를 검색할때 검색되지 않도록 해준다.\n\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/baekjoon1005/draw3.png?raw=true)\n\n그리고 이 행동을 계속 반복해주면 위상정렬이 나오게 된다.\n\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/baekjoon1005/draw4.png?raw=true)\n\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/baekjoon1005/draw5.png?raw=true)\n\n\n많이 생략한 감이 있어 추후에 추가 가능하면 추가하도록 하겠다.\n\n이렇게 계속 풀어가면서 하다보면 결과 배열이 나오게 되는데 사실 결과 배열은 여기서 그렇게 필요하지 않다.\n우리가 원하는건 시작하는 부분과 순서가 중요하기에 배열을 따로 기재하지 않았다.\n\n그러면 아까 맨처음 위에서 언급한 방법을 함께 사용하여 만들 수 있게 된다.\n\n순서는 위상정렬을 하면서 나타나게되니깐 각 노드들에게 자신이 지어지기까지 걸리는 시간을 기본으로 저장해두고 위상정렬을 하면서\n나오는 순서에 맞춰서 서로 더해주면 된다.\n\n그래서 나중에는 원하는 데이터를 그냥 인덱스 값만 입력하면 그 인덱스에 저장되어있던 총 건축시간을 출력만 하면 되는 것이다.\n\n그렇게 해서 만들어진 것이 아래의 코드이다.\n\n\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\ntypedef struct lineData{\n    int count; //데이터를 가지고 있는 개수\n    int totalTime;//지금 현재 총 건축시간\n    int arr[1000];//간선들의 정보를 넣어줄 배열\n}lineData;\nvoid push(lineData * data,int next){\n    (*data).count++;\n    (*data).arr[(*data).count - 1] = next;\n}\n\nint main(){\n    int i; //for구문의 변수\n    int repeatCount;//총 반복 횟수\n    int buildCount,buildRule;//짓는 건축 개수, 건축 순서의 정보 개수\n    int before,after;//이전 건물, 이후 건물 변수\n    scanf(\"%d\",&repeatCount);//총 반복 횟수 입력\n    int buildDelay[1001];//각각의 건물의 건축시간\n    \n    int outDegree[1001];//각 노드의 받는 간선의 개수\n    lineData graph[1001];//각 노드의 간선 정보\n    int queue[1000];//정점의 큐\n    int count = 0;//큐 인덱스를 받기 위한 변수\n    lineData result;//위상 정렬 출력 배열\n    for(int repeat = 0;repeat < repeatCount; repeat++){\n        scanf(\"%d %d\",&buildCount,&buildRule);\n\n        for(i =0;i<buildCount;i++){\n            int temp; \n            scanf(\"%d\",&temp);//건축시간 입력\n            //각각의 건축물에다가도 넣고 각 노드의 간선 정보의 최종시간에 넣어준다.\n            buildDelay[i] = graph[i].totalTime = temp;\n            graph[i].count =0;//나중에 재사용될 변수임으로 초기화해줌\n            outDegree[i] = 0;//위와 마찬가지임\n        }\n            \n        for(i =0;i<buildRule;i++){\n            scanf(\"%d %d\",&before,&after);//이전 빌딩 이후 빌딩의 입력\n            push(&graph[before - 1],after);//이전 빌딩의 인덱스에 이후 빌딩의 숫자를 넣어줌\n            outDegree[after - 1] += 1;//간선개수의 정보에 하나를 추가함\n        }\n\n        while(1){\n            count = 0; //0을 받은 횟수이자 큐의 인덱스\n            //총 건물의 개수만큼 for구문 실행\n            for(i =0; i < buildCount; i++){\n                //정점인 인덱스를 찾아봄\n                if(outDegree[i] == 0){\n                    //찾은 경우에 큐에 추가함\n                    queue[count] = i + 1;\n                    count++;\n                    //한번 정점이 되어 큐에 들어간 인덱스는 -1로 설정되어 정점 검사시에 확인되지 않도록 한다.\n                    outDegree[i] = -1;\n                    push(&result,i + 1);\n                }\n            }\n            //정점이 없는 경우 while구문을 탈출한다.\n            if(count == 0) break;\n\n            for(i = 0;i <count;i++){\n                for(int j = 0;j < graph[queue[i]- 1].count;j++){\n                    int nodeNum = graph[queue[i] - 1].arr[j] - 1; //간선이 가야할 노드의 숫자\n                    //간선의 총 시간이 간선의 기존 건축시간과 이전 건축물의 총 건축시간의 합보다 작을 경우\n                    //간선이 가야할 노드의 총 시간을 바꿔준다.\n                    if(buildDelay[nodeNum] + graph[queue[i] - 1].totalTime > graph[nodeNum].totalTime){\n                        graph[nodeNum].totalTime = buildDelay[nodeNum] + graph[queue[i] - 1].totalTime;\n                    }\n                    //간선의 총 개수를 하나 줄인다.\n                    outDegree[nodeNum] -= 1;\n                }\n            }\n        }\n        int resultIndex;\n        //찾고자하는 인덱스의 값을 받는다.\n        scanf(\"%d\",&resultIndex);\n        //인덱스 출력\n        printf(\"%d\\n\",graph[resultIndex - 1].totalTime);\n        \n    }\n    return 0;\n}\n```\n\n\n[blog1]: https://m.blog.naver.com/ndb796/221236874984\n[blog2]: https://gmlwjd9405.github.io/2018/08/27/algorithm-topological-sort.html\n[큐]: https://ko.wikipedia.org/wiki/%ED%81%90_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)\n","tags":["c","baekjoon","algorithm","studying"],"dates":["2022-03-07T04:25:22Z","2022-03-07T04:23:48Z","2022-03-07T04:23:02Z","2022-03-07T03:05:50Z","2022-03-05T16:35:20Z","2022-03-05T10:48:43Z"]},{"id":"4","parent":"__SOURCE__","internal":{"type":"Post","contentDigest":""},"children":[],"title":"졸업 작품 준비","content":"\n저번 포스트에서 대학교 다니면서 조기 졸업으로 인해서 반드시 해야 될 조기 졸업에 관해서 포스팅을 하려고 한다.\n현재는 2학년 1학기 때 구상했던 애플리케이션으로 조졸 작품을 낼 생각이다.\n\n","tags":["Graduate","졸업"],"dates":["2022-08-20T09:13:49Z"]},{"id":"5","parent":"__SOURCE__","internal":{"type":"Post","contentDigest":""},"children":[],"title":"typscript webpack electron으로 애플리케이션 만들기","content":"\n# Electron 앱 제작\n   \n--//\n..first link{+first+}\n..second link{+second+}\n..third link{+third+}\n//--\n\n## 2022-04-02\n{+first+}오랜만에 포스팅을 하긴 하는데 대학교 수업이 2학년이 들어서고 생각보다 많아서 백준 사이트 코딩과 여러가지를 꾸준히 해오긴 했는데 보여줄게 없다... \n\n\n사실 홈페이지 제작은 기숙사에 들어오면서 모니터 해상도가 달라서 디자인을 하기 힘들어 일단 잠정 보류로 냅뒀다. 그래서 백준을 열심히 한 것 같다.\n\n그리고 백준만 하다보니 너무 힘들어서 뭐라도 만들어야겠다는 생각으로 만들기 시작했다.\n\n남자들이라면 모를리가 없는 꺼토미 히라를 크롤링해서 데이터를 앱으로 제작해보려 한다.\n크롤링 노드는 이미 다 만들었다. 이 포스팅의 주요 이유는 바로 webpack typescript electron 의 애플리케이션 제작과 개발 환경 제작이다. \n나름 이것도 꽤 오랜 시간을 공들여 가면서 만들었다.\n\n크롤링 관련 node는 추후에 설명하기로 하자.\n\n들어가기에 앞서 이 글의 제작은 필자의 공부 목적으로 작성되었지만 필자도 [이거]보면서 제작했다.\n필자가 쓴 글이 이해가 되지 않는다면 들어가서 보면서 하는 것도 방법이다. 하지만 여기서는 ts가 아닌 js를 사용하기 때문에 그 차이점으로 인해서 추가 기록하는 느낌이라고 생각하면 될 것 같다.\n\n기본적인 틀은 npm init으로 시작하였다.\n시작하기 전에 주요 node module들 다 대충 훑고 넘어가보도록 하겠다.\n\n```\n    \"@babel/core\": \"^7.17.8\",\n    \"@babel/preset-env\": \"^7.16.11\",\n    \"@babel/preset-react\": \"^7.16.7\",\n    \"@types/react\": \"^17.0.43\",\n    \"@types/react-dom\": \"^17.0.14\",\n    \"babel-loader\": \"^8.2.4\",\n    \"css-loader\": \"^6.7.1\",\n    \"electron-reload\": \"^2.0.0-alpha.1\",\n    \"electron-reloader\": \"^1.2.3\",\n    \"sass\": \"^1.49.11\",\n    \"sass-loader\": \"^12.6.0\",\n    \"style-loader\": \"^3.3.1\",\n    \"typescript\": \"^4.6.3\",\n    \"webpack\": \"^5.71.0\",\n    \"webpack-cli\": \"^4.9.2\"\n```\n\n2022.04.03일 기준으로 이렇게 일단 있다. @types는 타입스크립트에서 사용할 수 있도록 해주는 노드 모듈이라고 생각하면된다.\n\n우선\n```\nnpm init -y\n```\n실행하여 package.json을 초기화 시켜준다.\n\n```shell\nnpm install --save-dev electron electron-reload typescript\n```\n\n이렇게 기본적인 것만 실행해서 다운 받아준다.\n\n```\n  \"scripts\": {\n    \"ts-c\": \"cd ./ts & tsc -w\",\n    \"watch\": \"webpack --config webpack.common.js --watch\",\n    \"start\": \"set NODE_ENV=development&&electron .\",\n    \"dev\": \"npm run ts-c & npm run watch & npm start\"\n  },\n```\n\n그 후 package.json에서 스크립트 부분을 살짝 고쳐준다. 사실 추후에 고쳐야 될지 모르겠지만 일단 이렇게 만들었다.\n\n그리고 내가 제작할 애플리케이션 파일 구조는 이렇게 생겼다.\n\n```\nRootFile\n│  index.html\n│  package-lock.json\n│  package.json\n│  webpack.common.js\n│\n├─.vscode\n│      tasks.json\n│\n├─build\n│  └─js\n│          app.js\n│\n├─js\n│  ├─electron\n│  │      main.js\n│  │      preload.js\n│  │\n│  └─react\n│          app.js\n│          index.js\n│          index.scss\n│\n└─ts\n    │  tsconfig.json\n    │\n    ├─electron\n    │      main.ts\n    │      preload.ts\n    │\n    └─react\n            app.tsx\n            index.tsx\n```\n\n위 파일 구조에서 볼 수 있듯이 electron의 실행 파일은 js/electron/main.js에 존재한다. 따라서 package.json에서 실행 파일의 위치를 변경해주어야한다.\n```\n  \"main\": \"./js/electron/main.js\",\n```\n\n그 후 ts폴더 안에 tsconfig.json을 생성해서 정의해주었다.(tsconfig json의 속성값을 알고 싶다면 tsc --init하면 기본 주석처리된 모든 속성값이 나오므로 확인하면 된다.)\n\n```json\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react\",                                \n    \"module\": \"commonjs\",                                \n    \"esModuleInterop\": true,                             \n    \"rootDir\": \"./\",\n    \"outDir\": \"../js\"\n  }\n}\n```\n이 config에서 제일로 중요한 곳은 `\"jsx\":\"react\"`이다.  \n저거 없으면 추후에 넣을 react가 안 돌아가므로 꼭 넣어야한다.  \n\n`rootdir`는 그 tsconfig 파일이 컴파일할때 어느 부분의 폴더부터 컴파일했으면 좋겟는지 알려주는 속성값이고\n\n`outDir`는 그 컴파일한 파일들을 저장 시키게 해주는 폴더 위치라고 생각하면된다.\n\nmain.ts를 만들기 전에 우선 기본적인 창을 띄워줄 html를 만들어줘야한다.\n아는 사람도 있고 모르는 사람도 있겠지만 electron의 UI는 모두 html로 설계되고 제작되기 때문에 처음 인덱스가 필요하다.\n\n그리고 가장 중요한건 electron는 single page application이다. 따라서 html를 여러개를 넣을 순 있지만 권장하지 않는다.\n\n\n```html\n<!--index.html-->\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\"/>\n    <meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self'\"/>\n  </head>\n  <body>\n    <div id=\"root\">\n    </div>\n    <script src=\"./build/js/app.js\"></script>\n  </body>\n</html>\n```\n사실 이 파일에는 많이 뭐가 들어가지 않는다. 애초에 이 index.html는 우리가 사용할 react와 electron를 연결해줄 매개체 밖에 되지 않기에 \n많이 들어가지 않는다.\n그리고 node js의 모듈을 기본적으로 사용하기 때문에 보안의 위험이 굉장히 큰 편이다. [sercutiy of electron]\n\n따라서 안에 들어가있는 스크립트만 사용할 수있도록 CSP를 걸어 놓는다. \n이는 electron가 권장하는 방법이라고 한다.\n\n마지막 스크립트 태그를 보면 알겠지만 app.ts가 app.js로 변환되어서 build폴더 안에 넣어지게 된다.\n\n이제  ts/electron 파일에 가서 실행할 파일을 만들어주자.\n\n```typescript\nconst { BrowserWindow,app } = require('electron'); \nconst path = require('path');\nconst env = process.env.NODE_ENV || 'development';\n```\n\n필요 노드다 3번째 줄은 개발환경에서 실했을때 추후에 추가할 hot reload를 위한 줄이다.\n\n\n```typescript\nfunction createWindow() {\n  const win = new BrowserWindow({\n    width: 1200,\n    height: 800,\n    backgroundCoor: \"white\",\n    webPreferences: {\n      NodeIterator: false,\n      worldSafeExecuteJavascript : true,\n      contextIsolation: true,\n      preload : path.resolve(path.join(__dirname, \"preload.js\"))\n    }\n  })\n\n  win.loadFile('index.html');\n  \n}\n```\n아무 것도 없이 electron을 실행했을 때는 아무 것도 안 뜨기 때문에 창을 하나 만들어줘야한다.\n\n창을 만들고 그 창에다가는 index.html를 넣으면 된다.\n\n\n```typescript\nif (env === 'development') {\n  require('electron-reload')(path.join(__dirname,'..','..'), {\n      electron: path.join(__dirname,'..','..','node_modules','electron')\n  });\n}\n```\n\n그렇게 되면 전체 코드는 이렇게 된다.\n\n```typescript\nconst { BrowserWindow,app } = require('electron'); \nconst path = require('path');\nconst env = process.env.NODE_ENV || 'development';\n\nfunction createWindow() {\n  const win = new BrowserWindow({\n    width: 1200,\n    height: 800,\n    backgroundCoor: \"white\",\n    webPreferences: {\n      NodeIterator: false,\n      worldSafeExecuteJavascript : true,\n      contextIsolation: true,\n      preload : path.resolve(path.join(__dirname, \"preload.js\"))\n    }\n  })\n\n  win.loadFile('index.html');\n  \n}\n\n// If development environment \nif (env === 'development') {\n  require('electron-reload')(path.join(__dirname,'..','..'), {\n      electron: path.join(__dirname,'..','..','node_modules','electron')\n  });\n}\napp.whenReady().then(createWindow)\n```\n\n그리고 개발모드에서만 실행되는 hot reload는 electron-reload이라는 모듈을 이용하게 되는데 현재 main.ts가 있는 위치가 최상위 폴더가 아니므로 꼭 주의해야한다.\nnode.js에서 기본적으로 제공해주는 `__dirname`은 현재 코드가 실행되는 위치이므로 ts/electron이 되어 버리기에 꼭 폴더 위치를 재조정해줘야 한다.\n아니면 실행할 수없는 파일이라고 뜨며 파일이 실행되지 않는다.\n\n이제 react를 설정할 것이다. 위에 이미 다운 받은 것들을 제외하고 나머지 것들을 다 다운받아준다.\n\n```\nnpm install --save-dev sass sass-loader style-loader @babel/core @babel/preset-env @babel/preset-react @types/react @types/react-dom babel-loader css-loader webpack webpack-cli\n```\n\n많다... 그래도 다 쓰니깐 넣어 놓도록 하자\n\nreact를 제작하기 전에 웹팩 설정 파일을 간단히 만들고 갈 것이다.\n\n```javascript\n//webpack.common.js\n\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'development',\n  entry: './js/react/index.js',\n  // TODO: Explain Source Map\n  devtool: 'inline-source-map',\n  target: 'electron-renderer',\n  // plugins: [\n  //   new webpack.ProvidePlugin({\n  //      \"React\": \"react\",\n  //   }),\n  // ],\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: [[\n              '@babel/preset-env', {\n                targets: {\n                  esmodules: true\n                }\n              }],\n              '@babel/preset-react']\n          }\n        }\n      },\n      {\n        test: [/\\.s[ac]ss$/i, /\\.css$/i],\n        use: [\n          // Creates `style` nodes from JS strings\n          'style-loader',\n          // Translates CSS into CommonJS\n          'css-loader',\n          // Compiles Sass to CSS\n          'sass-loader',\n        ],\n      }\n    ]\n  },\n  resolve: {\n    extensions: ['.js'],\n  },\n  output: {\n    filename: 'app.js',\n    path: path.resolve(__dirname, 'build', 'js'),\n  },\n};\n\n```\n앞서 알려주었던 동영상에서 동영상 젝자의 깃허브에 있는 것을 복사 해왔다. 거기서 몇가지만 지웠는데 사용하지 않을 플러그인과 모듀을 지워 주었다.그리고 위쪽 코드에서 `entry`의 코드만 우리가 현재 사용하고 있는 main.js의 위치로 바꿔주면 된다.\n그리고 빌드 된 후 나온 파일은 코드 아래쪽에 있는 `output`에 들어가게 된다.\n\n마지막으로 react의 설계다. react를 해보았거나 react를 잘 아는 사람들은 쉬울 수도 있다.\n```node\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport ReactDOMClient from 'react-dom/client';\n\n\nimport App from './app'\nimport './index.scss';\n\nconst rootElement = document.getElementById(\"root\")\nconst root = ReactDOMClient.createRoot(rootElement)\nroot.render(<App/>)\n```\n그냥 간단한 인덱스이다. 여기서 주의해야 할 것은 `ReactDOM.render()`가 raect가 react18 업데이트 되면서 지원이 중지가 된다고 하여서 \n`ReactDOMClient.createRoot`를 사용해 주었다. 자세한 사항은 [Replacing render with createRoot]를 참조하면 좋을 것 같다.\n\n그래서 작동과 환경 제작의 목적이므로 아무것도 넣지 않고 그냥 App만 넣어서 정의해주었다.\n\n\n```node\nimport React from \"react\";\nexport default function App(){\n  return (\n  <>\n    <h1>I am App Component</h1>\n    <button onClick={() => {\n      // @ts-expect-error\n      electron.notificationApi.sendNotification(\"my custom notification\")\n    }}>Notify</button>\n  </>\n  )\n}\n\n```\n그 앱에 관한 코드이다. 역시 아무것도 없다. 하지만 알아야하는 곳이 있는데 현재 html과 그 관한 js코드들은 인증 받지 못한 곳에서 들어온 코드라면 실행이 불가능하게 설계되어있다.\n그렇다면 데이터를 react와 electron끼리 서로 주고 받을 때 어떻게 해야되는지 모를 것이다. 그게 바로 `electron.notificationApi` 여기서 볼 수 있는데 electron에 preload라는 속성값이 있어서 거기서 값을 보내거나 받아 올 수 있다.\n\n하지만 typescript에서는 글로벌에 변수로 선언해서 값을 받아 올 수 있다 하여 선언을 받지 않았기에 error을 출력하게 되는데 이때 `// @ts-expect-error`를 사용해줌으로써 error가 날 필요가 없고 값이 들어오는 곳이라고 지정해줄 수 있다.\n\n\n```typescript\n//electron/preload.ts\nconst { ipcRenderer, contextBridge} = require('electron');\n\ncontextBridge.exposeInMainWorld('electron',{\n  notificationApi : {\n    sendNotification(message){\n      console.log(message)\n      ipcRenderer.send('notify',message);\n    }\n  }\n})\n```\npreload의 기본 형태를 잡아주기 위해서 간단한 명령어만 넣었다. `contextBridge.exposeInMainWorld` 말그대로 모든 스크립트에서 전역을 사용할 수 있도록 만들어주는 방식이다.\n전역변수의 이름을 electron으로 설정해주는 것이다. 그리고 그 `electron`안에는 notificationApi라는 Api가 있다. 이 방식을 사용해서 react에서 상호작용시에 데이터를 보내거나 받을 수 있게 되는 것이다.\n\n\n이렇게 짜면 빌드는 충분히 되지만 더 낫고 편안한 환경을 만들기 위해서 추가적으로 작업을 한게 있다.\n\nvscode 자체에서 지원해주는 `tasks.json`과 extension으로 react 컴포넌트 관리이다.\n우선 `F1`을 눌러서 실행 설정들을 열서 tasks 검색후 \n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/makingElectronApp/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(134).png?raw=true)\n를 눌러서\n\n감지 작업 중 npm:start를 눌러서 tasks.json를 제작해준다.\n사실 그냥 .vscode 만들어서 tasks.json를 만들어줘도 된다.\n\n```json\n{\n\t\"version\": \"2.0.0\",\n\t\"tasks\": [\n\t\t{\n\t\t\t\"label\": \"test App\",\n\t\t\t\"dependsOn\": [\n\t\t\t\t\"npm: watch\",\n\t\t\t\t\"npm: ts-c\",\n\t\t\t\t\"npm: start\"\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"shell\",\n\t\t\t\"label\": \"npm: ts-c\",\n\t\t\t\"command\": \"npm run ts-c\",\n\t\t\t\"presentation\": {\n\t\t\t\t\"group\": \"app test component\",\n      }\n\t\t},\n\t\t{\n\t\t\t\"type\": \"shell\",\n\t\t\t\"label\": \"npm: watch\",\n\t\t\t\"command\": \"npm run watch\",\n\t\t\t\"presentation\": {\n\t\t\t\t\"group\": \"app test component\",\n      }\n\t\t},\n\t\t\n\t\t{\n\t\t\t\"type\": \"shell\",\n\t\t\t\"label\": \"npm: start\",\n\t\t\t\"command\": \"Start-Sleep -s 5 | npm start\",\n\t\t\t\"presentation\": {\n\t\t\t\t\"group\": \"app test component\",\n      }\n\t\t}\n\t]\n}\n\n```\n\n이게 json 설정이다. 빌드를 위해서는 3개의 멸령어가 실행 되어야 한다. typescript에서 javascript으로 변환해주는 컴파일러 그리고 react를 script태그에다가 넣어줄 수 있게 바꿔주는 동작, 마지막으로 electron의 변경마다 hot reload를 시켜주는 동작으로 총 3개인데 하나 씩 실행 시키기 귀찮아서 묶어버렸다.\n\n```json\n{\n\t\"label\": \"test App\",\n\t\"dependsOn\": [\n\t\t\"npm: watch\",\n\t\t\"npm: ts-c\",\n\t\t\"npm: start\"\n\t]\n},\n```\n이건 별거 아니고 그냥 3개의 명령어를 실행 시키기 위해서 한꺼번에 실행을 도와주는 시작이다.\nlabel은 필자가 한것처럼 안하고 다른 이름으로 작성해도된다. dependsOn은 이름을 바꿀 수 있지만 나머지 tasks들의 label과 이름을 맞춰야한다.\n\n```json\n{\n\t\"type\": \"shell\",\n\t\"label\": \"npm: ts-c\",\n\t\"command\": \"npm run ts-c\",\n\t\"presentation\": {\n\t\t\"group\": \"app test component\",\n\t}\n}\n      \n```\n타입스크립트의 컴파일이다.\n타비스크립트를 작성하고 저장할때마다 지속적으로 업데이트 해준다.\n\n```json\n\t\t{\n\t\t\t\"type\": \"shell\",\n\t\t\t\"label\": \"npm: watch\",\n\t\t\t\"command\": \"npm run watch\",\n\t\t\t\"presentation\": {\n\t\t\t\t\"group\": \"app test component\",\n      }\n```\nreact의 변경이 확인되면 실행해서 다시 업데이트 해주는 동작을 해주는 프로세스를 실행해준다.\n\n```json\n{\n\t\"type\": \"shell\",\n\t\"label\": \"npm: start\",\n\t\"command\": \"Start-Sleep -s 5 | npm start\",\n\t\"presentation\": {\n\t\t\"group\": \"app test component\",\n      \t}\n}\n```\n\n\n마지막으로 electron 그 자체를 실행시켜주는 tasks이다. \n하지만 먼저 실행되면 react가 로드 되지 않은 상태로 샐행되기 때문에 Start-Sleep를 통해서 몇 초 쉰다음에 실행해주도록 만들어주었다.\n\n이렇게 하면 이제는 `F1` > `tasks: run tasks` > `start with no scan`이렇게 하면 자동으로 실행해준다.\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/makingElectronApp/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(135).png?raw=true)\n\n실행하면 이렇게 3개가 동시에 보인다!\n\n마지막 필요한 vscode extension는 `review.js`다.\n\n메인 인덱스에 넣었다가 뺐다 하는 번거로움을 없애기 위해서 사용한다. \n자세한 내용은 필자보다 [사이트]가 잘 해놨으니깐 확인해보길 바란다.\n\n\n[이거]:https://www.youtube.com/watch?v=VCl8li22mrA\n[sercutiy of electron]:https://www.electronjs.org/docs/latest/tutorial/security\n[Replacing render with createRoot]:https://github.com/reactwg/react-18/discussions/5\n[사이트]:https://previewjs.com/\n","tags":["html","typescript","design","studying","webpack"],"dates":["2022-07-05T18:12:31Z","2022-04-03T05:15:16Z","2022-04-03T05:13:21Z","2022-04-02T16:01:24Z"]},{"id":"6","parent":"__SOURCE__","internal":{"type":"Post","contentDigest":""},"children":[],"title":"블로그 디자인 및 제작","content":"\n# 블로그 디자인 기록\n   \n--//\n..first link{+first+}\n..second link{+second+}\n..third link{+third+}\n//--\n\n## 2022-02-14\n{+first+}\n처음 시작했을 때는 별 생각 없이 시작했던 것 같다. \n\n나름 디자인에 자신있다고 생각했던 것 같은데 막상 해보니깐 그렇지도 않은 것 같다는 생각이 들었다. 2022년 2월 초에 시작하게 된 블로그 만들기는\n2월 21일이 된 와중에도 다 디자인을 완료하지 못했다.\n\n그래도 나름 현재까지 진행 상황과 어디까지 만들었는지에 대해서 천천히 읊고 기록해 놓고자 작성하게 되었다.\n\n\n![](https://github.com/dennis0324/blogPost/blob/main/data/pictures/myBlogDesign/design1.png?raw=true)\n별 생각없이 만들긴 했지만 그래도 이때 만들 당시만해도 괜찮다는 생각이 들었다.\n\n남들과는 좀 다른 홈페이지를 만들어 보려고 하였지만 결과는 처참한거 같다.\n\n나름 다른 디자인들도 만들어 보겠다고 만들던 것들에서 약간식 수정하여 여러 디자인들을 만들어 보았지만,\n디자인에 견문이 넓던 것도 아니였기에 아쉬운 결과가 나온 것 같다.\n\n>첫번 째 디자인\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/myBlogDesign/design2.png?raw=true)   \n\n>두번 째 디자인\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/myBlogDesign/design3.png?raw=true)   \n\n>세번 째 디자인\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/myBlogDesign/design4.png?raw=true)   \n\n>네번 째 디자인\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/myBlogDesign/design5.png?raw=true)   \n\n![alt text](https://jekyllthemes.io/images/themes/simples-jekyll-theme.webp?_cchid=eccad4a7c25f449a0df27824207f324b)\n>[original website](https://jekyllthemes.io/theme/simples-blog-jekyll-theme)\n\n위에 이미지는 내가 구글링 하다가 발견한 사진으로 필자가 봤을 때는 깔끔해보이는 사이트 디자인이라고 생각하였다.\n그래서 이것저것 찾아보니 사이트가 더 다채워지는 요소 중 하나가 사진의 유무라는 것을 디자인을 찾아보다가 느끼게 되었다.\n\n내가 만든 게임이 있었다면 사진과 같이 블로그를 만들었겠지만 만든 게임이 없어서 아쉬울 따름이다. \n\n사진이 없기에 만들면서 그냥 심플하게 만들기로 결심했다. \n\n어짜피 코딩과 공부 기록 목적이라면 알록달록 이쁜 것도 좋겠지만, 많은 색깔이 들어가는 걸 안 좋아하는 나로써는\n단순한 색과 단순한 디자인이 더 마음에 끌렸기에 이렇게 디자인한것 같다.\n \n >최종 디자인\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/myBlogDesign/finaldesign.png?raw=true)\n\n이렇게 해서 대문 디자인을 대충 끝난 상태였지만, 아직 프로젝트 페이지에 들어갈 rest api 와 디자인을 만들지 못하였다. 물론 tech 페이지도 말이다...\n\n## 2022-02-23\n\n대문이 얼추 완성 되고 시작되는 tech 파트에 대한 기록이다.\n\n디자인을 하기 전에 그래도 어려운거 먼저 끝내겠다는 마인드를 가지고 rest api를 이용해서 github를 통해 블로그 포스팅을 가져 와야겠다고 생각했다. \n물론 처음부터는 아니고 같은 대학교 동기 형이 있는데 동기형이 알려줬다. [jdeokkim]\n(너무 감사하게 생각하고 있다. 형 아니였으면 NAS로 데이터베이스까지 건드려서 할 뻔했다. 사실 하려고 했다...)\n\n그래서 예전에 이 블로그 제작 전에 너무 장황하게 만들어 놔서 아무것도 못하고 그냥 방치해둔 react로 만들던 프로젝트가 있는데 거기서 사용한 [octokit]를 사용하고자 한다. \n\n```js\n//fileName: post.js\n\nconst octokit = new Octokit({auth: `token my PRIVARYCODE`})\n```\n로 시작해서 rest api를 사용하여 github에서 데이터를 불러올 생각이다.\n\n```js\nexport const getPost = async (menuName) => {\n   const path = await octokit.request(\"GET /repos/{owner}/{repo}/contents/{menu}\",{\n         owner:\"dennis0324\",\n         repo:\"blogPost\",\n         menu:menuName\n       })\n      ...\n```\n위에 코드는 나의 깃허브 페이지에서 blogPost라는 repository에서 데려오는 것이다. \n이를 통해서 불러 들인 포스트한 게시글들을 처음 테크 목차에 들어가면 무엇에 들어갈 것인지 결정해주는 역할이라고 생각하면 될것 같다.\n\n```js\n   ...\nconst testing = await octokit.repos.getContent({\n      owner:\"dennis0324\",\n      repo:\"blogPost\",\n      path: \"tech/myBlogDesign.md\"\n    })\n    ...\n```\n\n이 코드는 올린 글 목록을 보는 것이 아닌 올린 글의 내용들을 다시 불러오는 것이다.\n여기서 불러온 코드는 아래의 코드로 디코딩을 한 번 거쳐서 출력된다.\n\n```js\n    let decoded = Base64.decode(testing.data.content);\n```\n\n필자는 이 구간에서 생각보다 많이 헤메였다. 처음에 md 파일이 무슨 형식으로 인코딩 되어있는지도 자세히 몰랐고, 심지어 한글이 utf-8 형식이라 unicode에 맞지 않아 한글이 깨져서 나오는 것이다.\n그래서 여기서 힘좀 많이 들였다.\n\n\n찾아보니 md 파일은 *BASE 64* 로 인코딩 되어있었고 디코딩을 하기 위해서 다른 스크립트 파일을 이용해서 하면 된다는 것을 깨달았다. (필자가 이렇게 짧게 쓰긴 했지만 실력이 부족했어서 나름 오랬동안 찾아봤던 것 같다.)\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/js-base64@3.6.1/base64.min.js\"></script> <!--base64 해독 역할-->\n```\n\n이렇게 하니까 정상적으로 출력하는 것을 볼 수 있었다.\n![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/myBlogDesign/restapiresult.png?raw=true)\n\n이렇게 만들고 보니 글에서의 목차가 보이지 않다는 것을 깨달아버렸다.\n그래서 고심하다가 나름 나만의 정의 만들어서 목차를 웹사이트 쪽에서 자동으로 생성하게 만들기로 하였다.\n\n필자가 올린 위에 사진에 첫 라인에 보면 \n```\n--//\n..first link{+first+}\n..second link{+second+}\n..third link{+third+}\n//--\n```\n라는 부분이 있을텐데 이 부분이 목차를 생성할 때 도와주는 부분이라고 생각하면 된다.\n\n\n```js\n    postedIndexs.forEach((val,index) => {\n      if(val.innerHTML.indexOf(\"--//\") >= 0 && val.innerHTML.indexOf(\"//--\") >= 0){\n        var re = /[\\n\\-\\/]/g; //엔터키, --// 또는 //--를 제거한다고 가장 앞에있는 ..를 제거한다.\n        temp = val.innerHTML.replace(re,\"\").replace(\"..\",\"\")\n        temp = temp.split(\"..\") //..를 분해하여 배열로 설정한다.\n\n        val.remove()\n        \n\n        //각 키와 연결 키를 설정해둔다.\n        temp.forEach((key,index) => {\n          //{+[linkName]+}를 분해하여 만든다.\n          temp[index] = key.replace(/[\\{]\\s*/g,\",\").replace(/[\\}\\+]\\s*/g,\"\").split(\",\")\n        })\n        console.log(temp)\n      }\n      else{\n        temp.forEach((linkList,index) => {\n          if(val.innerHTML.indexOf(\"{+\"+linkList[1]+\"+}\") >= 0){\n            console.log(val)\n            const node = document.createElement(\"div\") //div 설정\n            node.classList.add(linkList[1]) //div 생성 및 클래스 생성하여 연결할 링크 설정\n            node.innerHTML = linkList[1] //생성된 div에다가 텍스트 설정후 표시\n            postMenu.appendChild(node) //생성된 div post-menu라는 아이디에다가 추가함\n            val.classList.add(\"link\",linkList[1]) //\n            val.innerHTML = val.innerHTML.replace(\"{+\"+linkList[1]+\"+}\",\"\")\n            \n          }\n          console.log()\n  \n        })\n      }\n\n    })\n```\n\n사실 실력이 좋지 않아 코드가 이쁘지 않다. 굉장히 난잡하다. \n그래서 블로그 다 만든 후에 코드 이쁘게 짜는 법좀 공부해 보려고 한다. 항상 만들다 보면 스파게티 코드가 완성되어 나 스스로 스트레스를 너무 많이 받는 것 같다.\n\n사실 위 코드가 하는 행동은 간단하다. rest api에서 받아온 markdown코드를 누가 해석해주냐면 우리 [marked]가 해준다. \n이 marked가 각 문장마다 h1, p 등등으로 바꾸어서 만들어 주는데 목차를 거의 위에다가 놓아서 사실 목차 찾는 시간이 오래 걸리지 않아 그냥 foreach문으로 돌려버렸다.\n더 좋은 방법이 있다면 찾아봐야겠다...\n\n우선 모던 p를 불러와 '--//' '//--'가 동시에 존재 하는 지 확인하고 확인이 되면 엔터키, -, /를 제거 후 배열을 만들기 쉽게 가장 앞에 있는 ..만 없애준다.\n그러면 \n```\nfirst link{+first+}..second link{+second+}..third link{+third+}\n```\n이런식으로 나올텐데 여기서 split으로 돌려서 단순히 배열을 제작한 것이다. 사실 더 간단한 방법이 있었지만 나중에 블로그 자체가 아닌 깃허브에서 봐도 헷갈리지 않게 만들기 위해 \n나름대로의 보기 편안한 방법을 찾아서 한 것 같다.\n\n그리고 {이름}를 분해하여 각각 짤라서 배열을 나눠 다시 아까 사용한 배열을 넣어 이중배열을 만들어 줬다.\n그리고 나머지 else부분은 그냥 div 생성하고 안에 텍스트 및 이중배열에서 생성한 클래스 이름을 사용하여 노드 제작 후 index쪽에다가 넣어주는 것이다. \n그리고 이동하고 싶은 부분에 삽입하면 그 쪽에 있는 p라인에다가도 클래스를 넣는 방식이라고 생각하면 된다.\n\n이렇게 해서 tech 목차에 사용할 rest api 부분은 대충 다 만들었다.\n\n\n사실 디자인이 먼저라고 생각 하는 분들도 있을 것이라고 생각했지만 솔직히 api쪽 먼저 하고 받아오는 형식을 먼저 정하고 나중에 디자인을 정하는 것이 낫다는 생각이 들어\n먼저 한 것이다. 디자인들도 여러가지 생각해봤지만 아직 딱 정해진 것 없는 것 같다. 항상 디자인으로 스트레스 받는 것 같다.\n\n## 2022 - 02 -25\n막힌 부분이 있어서 하루를 보냈다.\n\n진짜 농담이 아니고 새벽 3시까지 모르는거 있어서 찾아보는 것도 대학교 과제하면서 이후로 오랜만인 것 같다. \n\n물론 군대를 갔다오면서 군대에서도 코딩을 시간 날 때 마다 했지만, 그래도 이렇게까지 오랫동안 붙잡고 있던 것도 오랜만이다.\n\n사실 더 쉬운 방법이 있다는 것을 알고 있었지만 내 오기가 생겨서 그만 두지 못했다. 컴퓨터를 끄는 것은 새벽 1시에 껐지만, 너무 열받아서 새벽 세시까지 핸드폰으로 뒤져봤다.\n그냥 너무 단순한 문제였는데 너무 힘들게 생각한게 아닌가 싶기도 하다.\n\n중간에 포기하고 그냥 홈페이지 DB를 하나 만들어서 거기다가 저장 해둘까 생각도 했다만... 더 뭔가를 벌리면 완성도 못한다는 생각에 계속 찾아보았던 거 같다.\n\n3시쯤 되어서야 뭐 내가 찾는거랑 비슷한거를 찾은거 같아서 북마크해두고 잤다.\n\n사실 글 작성일 및 업데이트된 날짜를 가져오는 것인데, 파일별로 정리해서 모아둔게 없던 것이다. rest api로는 무리가 있겠다 싶어서 graphql를 사용해서 하려 하니깐\n사실 아무것도 모르는 입장에서는 곤혹일 수 밖에 없었다.\n\n찾아도 내가 원하는 게 아무것도 안 나와서 답답해 죽는 줄 알았다.\n\n아침에 일어나서 결론 지은것은 미리 짜둔 기초 틀에 aliases를 사용하여 가져오는 파일들을 정리해서 가져오자고 계획를 하고 짜기 시작했다.\n\n필자가 작성한 방법이 정론법은 아니지만, 내가 원하는 결과를 도출시켜주는 하나의 과정이기에 일단 올려서 기록에 남긴다.\n\n```js\n const getData = await octokit.request(\"GET /repos/{owner}/{repo}/contents/{menu}\",{\n   owner:\"dennis0324\",\n   repo:\"blogPost\",\n   menu:menuName\n })\n```\n\n우선 restapi를 사용하여 파일이름을 다 한꺼번에 가져온다.\n\n그리고 그 배열을 바탕으로 qeury 구문을 제작해준다.\n\n```js\nvar commits = ``\n\n pathData.forEach((value,key) => {\n   console.log(value,key)\n   let putData = value[0].replace(\".md\",\"\") + `: history(path: \"`+value[1]+`\", first: 100) {\n     edges {\n       node { \n         committedDate \n         oid\n         author\n         {  \n           email\n         }\n       } \n     }\n   }\n   `\n   commits = commits.concat(putData)\n })\n```\n우선 aliases를 사용할 수 있도록 String으로 이어붙여 내부 query를 만들어 준 후\n\n```js\n    const query = `query RepoFiles($own:String!,$repo:String!){\n      repository(owner: $own, name: $repo) {\n        first: object(expression: \"main\") {\n          ... on Commit {\n            `+commits+`\n          \n        }\n      }\n    }\n  }\n  `\n\n```\n로 완성한다.\n\n그 후\n\n\n```js\n    const queryValue = {\"own\":\"dennis0324\",\"repo\":\"blogPost\"}\n\n    const endpoint = \"https://api.github.com/graphql\"\n\n    try{\n      fetch(endpoint,\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization':'bearer TOKEN'\n          },\n          body:JSON.stringify({\n            query:query,\n            variables: queryValue\n          })\n        })\n        .then(res=> res.json())\n        .then(json => console.log(json))\n    }\n    catch(e){\n      console.log(e)\n    }\n```\n\nfetch로 graphql를 불러온다. 이렇게 해서 포스트된 글, 포스트된 시간에 사용할 데이터 불러오는 것에 대한 코딩은 다 끝났다.\n\n\n[octokit]: https://octokit.github.io/rest.js/v18\n[marked]: https://github.com/markedjs/marked\n[jdeokkim]: https://github.com/jdeokkim\n","tags":["html","javascriopt","design","studying"],"dates":["2022-02-27T13:01:51Z","2022-02-27T13:01:37Z","2022-02-27T12:45:20Z","2022-02-27T12:32:42Z","2022-02-27T12:29:56Z","2022-02-27T12:24:31Z","2022-02-27T12:23:58Z","2022-02-27T11:35:09Z","2022-02-25T10:43:40Z","2022-02-24T11:16:27Z","2022-02-23T14:42:12Z","2022-02-23T14:35:57Z","2022-02-23T14:06:04Z","2022-02-23T13:53:12Z","2022-02-23T13:51:25Z","2022-02-22T08:01:01Z","2022-02-21T09:07:24Z","2022-02-21T09:00:49Z","2022-02-21T08:19:32Z"]},{"id":"7","parent":"__SOURCE__","internal":{"type":"Post","contentDigest":""},"children":[],"title":"블로그 디자인 및 제작","content":"\n## 2022 - 07 - 21\n\n만든다고 얘기하고 난 후에 약 5개월이 지났다. 공부 안한게 아니라 정확히 말하면 대학교 생활에 엄청 치이면서 살았다. 고등학교 생활보다 대학교 생활을 더 열심히 한거 같다.\n평소에 코딩을 하면서 지내왔지만, 이번 대학교 생활 텀 프로젝트로 인해서 만들던 모든 프로젝트를 중지하며 대학 생활을 하였다. \n\n그래도 열심히 집중해서 그런지 다행이도, 좋은 성적으로 마무리하였다.\n\n다시 본론으로 넘어와서 현재 블로그 현황에 대해서 말해보겠다.\n현재 블로그의 전반적인 디자인을 다 수정하여 바뀐것이 엄청 많다. \n\n기존에 일반 html 방식에서 vue-cli 방식으로 다시 전면적으로 수정하여 제작하였다.\n> 디자인 변경 후\n> ![image](https://user-images.githubusercontent.com/50710829/180042749-97058fd2-09ad-4f63-bea0-b3a886754171.png)\n\n현재 완성된 이미지이다.\n\n전에 포스트와 현재의 포스트와 비교하면 알 수 있듯이 엄청 많이 바뀌었다는 것을 알 수 있다. \n\n> 디자인 변경 전\n> ![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/myBlogDesign/finaldesign.png?raw=true)\n\n사실 변경한 계기는 오랜만에 블로그를 제작하다 보니 만들었던 블로그가 너무나도 마음에 들지 않았다.\n그래서 다시 전반적으로 수정하기로 마음을 먹고 고쳤다.\n\n> ADOBE XD 전반적인 디자인 \n> ![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/myBlogDesign2/xdCap.png?raw=true)\n\n이렇게 디자인을 마무리 짓고 vue에서 알다 싶히 컴포넌트를 제작후 서로 합치는 방식으로 제작하다니깐 \n각 파트를 나누어서 제작하고 서로 붙이는 과정을 거쳤다.\n\n![image](https://user-images.githubusercontent.com/50710829/180045028-e52f3225-7fd4-45c0-b03e-d36897331d24.png)\n\n이렇게 로고를 담당하는 파트와\n\n![image](https://user-images.githubusercontent.com/50710829/180045065-04fa1025-b350-480b-98bb-4cc5b00a9302.png)\n\n네비게이션을 담당하는 파트로 나뉘어 제작하게 되었다.\n\n심플한 디자인으로 홈 화면에 디자인하고 조금 특별한 방식으로 tech 페이지를 디자인해보았다.\n\n> ![alt text](https://github.com/dennis0324/blogPost/blob/main/data/pictures/myBlogDesign2/Tech_dark.png?raw=true)\n\n\n위에거는 XD에서 디자인한 모습이고,\n아래 모습은 실제 디자인한 모습이다.\n\n![image](https://user-images.githubusercontent.com/50710829/180047001-f52c1a27-40dd-4326-b4a4-ed00c72ddc28.png)\n\n완전히 디자인을 다 완성한건 아니지만, 추가적으로 모든 2달의 최대값이 62일 이므로 전체 표시값을 62로 정하고 2달의 실제 값을 더 진하게 표시하는 방식으로 제작하였다.\n\n위에 블로그 활동 표시 인디게이터 같은 경우에는 `vue`의 `watch`사용하여 특정 `property`가 변경되면 값에 따라 인디케티터가 변경되는  방식이다.\n\n```typescript\n// BlogPostStream.vue\n\nwatch:{\n    /**\n     * BlogPostData가 들어오면 circleIndicator가 사용할 수 있도록 만들어주는 `watch`함수입니다.\n     * \n     * @param newBlog 변경된 사항이 있으면 들어오는 매개변수입니다.\n     */\n    BlogPostData(newBlog){\n        /** proxy{} 없애주는 작업입니다. */\n        const PostChanged = JSON.parse(JSON.stringify(newBlog))\n\n        const date = this.startingDate as Date;\n        let tempDate = new Date(date.getFullYear(),date.getMonth(),date.getDate() + 1,date.getHours(),date.getMinutes(),date.getSeconds());\n        const startingDate = new Date(tempDate.getFullYear(),tempDate.getMonth() - 2,tempDate.getDate() - 2,date.getHours(),date.getMinutes(),date.getSeconds())\n\n        const blogPostStreamDatas:BlogPostStreamData[] = []\n        while(startingDate.toISOString().split('T')[0] !== tempDate.toISOString().split('T')[0]){\n\n            /** 저장하기 위한 임시 변수 생성 */\n            const blogPostStreamData:BlogPostStreamData = {} as BlogPostStreamData\n\n            /** 현재 루프 돌아가고 있는 date 앞 날짜만 가지고 오기 */\n            const a = tempDate.toISOString().split('T')[0]\n\n            blogPostStreamData.type = []\n\n            /** 현재 가지고 있는 모든 포스트 확인해보기 */\n            for(const node of PostChanged){\n                if(a === node.createdat.split('T')[0]){\n                    blogPostStreamData.type.push(0)\n                }\n                else if(a === node.updatedat.split('T')[0]){\n                    blogPostStreamData.type.push(1)\n                }\n            }\n            blogPostStreamData.date = a;\n            tempDate?.setDate(tempDate?.getDate() - 1);\n            blogPostStreamDatas.push(blogPostStreamData)\n        }\n        this.blogPostStreamData = blogPostStreamDatas\n    }\n},\n```\n\n우측과 마찬가지로 좌측도 비슷한 방식으로 만드는 것이다. \n\n\n```typescript\n// GithubStream.vue\n\nwatch:{\n    async startingDate(){\n        console.log('staringDate',this.startingDate)\n        /** 외부 백엔드 서버에서 특정 데이터를 받아옵니다. */\n        const response = await axios.get(`http://localhost:3000/githubContirbutions/?startingDate=${this.startingDate}`)\n        const githubResponse = response.data.data as githubContributionResponse \n        if(response !== undefined){\n            console.log(githubResponse)\n\n            const githubMonths = githubResponse.user.contributionsCollection.contributionCalendar.months.slice().reverse()\n            const githubWeeks = githubResponse.user.contributionsCollection.contributionCalendar.weeks.slice().reverse()\n\n            this.githubDataMonth = githubMonths;\n            this.githubDataWeek = githubWeeks;\n        }\n    }\n},\n```\n\n사실 이 부분을 설명하면 백엔드 부분의 코드도 같이 설명해야한다.\n\n\n```typescript\napp.get('/githubContirbutions/',async (req,res) => {\n    const responseQuery = req.query.startingDate as string\n    const startDate = new Date(responseQuery)\n    const QUERY = `\n                query testing($userName:String!, $toDate:DateTime, $fromDate: DateTime) { \n                    user(login: $userName) {\n                        contributionsCollection(from: $fromDate, to: $toDate) {\n                            contributionCalendar {\n                                totalContributions\n                                weeks {\n                                    contributionDays {\n                                    weekday\n                                    date \n                                    contributionCount \n                                    color\n                                    contributionLevel\n                                    }\n                                }\n                                months  {\n                                    name\n                                    year\n                                    firstDay\n                                    totalWeeks  \n                                }\n                            }\n                        }\n                    }\n                }`;\n    const queryValue = {\n        \"userName\":\"dennis0324\",\n        \"toDate\":new Date(startDate.getFullYear(),startDate.getMonth(),startDate.getDate(),startDate.getHours(),startDate.getMinutes(),startDate.getSeconds()),\n        \"fromDate\":new Date(startDate.getFullYear(),startDate.getMonth() - 2,startDate.getDate() + 1,startDate.getHours(),startDate.getMinutes(),startDate.getSeconds())\n    }\n    const endpoint = \"https://api.github.com/graphql\"\n    let commitDatas = await fetch(endpoint,\n    {\n        method: 'POST',\n        headers: {\n        'Content-Type': 'application/json',\n        'Authorization':`bearer ${GITHUB_TOKEN}`\n        },\n        body:JSON.stringify({\n        query:QUERY,\n        variables: queryValue\n        })\n    })\n    commitDatas = await commitDatas.json()\n    res.send(commitDatas)\n})\n```\n\n위에 코드는 express를 사용한 벡엔드 부분이다. 이렇게 해서 깃허브에서 기여 활동을 받아올 수 있다. \n","tags":["html","javascriopt","design","studying","vue","nodejs"],"dates":["2022-07-24T16:27:04Z","2022-07-20T17:53:05Z"]},{"id":"8","parent":"__SOURCE__","internal":{"type":"Post","contentDigest":""},"children":[],"title":"블로그 디자인 및 제작","content":"\n## 2022-08-08\n\n블로그 제작을 제작하면서 코딩도 코딩이지만 계속 디자인에 대해서 많은 고민을 하는것 같다.\n기존의 `pagination` 방식과 `infinite scroll(이하 무한 스크롤)` 방식에서 많은 고민을 하였지만, 현재 많은 앱들의 흐름을 보면\n인스타그램, 페이스북등과 같이 무한 스크롤을 많이 사용하는 것을 알 수 있다.\n\n그렇게 해서 무한 스크롤 방식으로 다시 고치게 되었다.\n\n블로그 스크롤 형식을 무한 스크롤로 하다보니 고쳐야할 것들이 한둘이 아니였다.\n\n그래서 기존에 있던 방식에서 바꾸었다.\n\n기존 버튼에서 누르면 데이터를 불러오는 방식에서 스크롤 하면 로딩하는 방식으로 고치다보니\n바꿔야 하는 함수가 너무 많았다.\n\n특히 스크롤 하면 위치를 파악하는 함수가 필요했다.\n\n기존에 `pagination`을 사용하는 방식에서 무한 스크롤를 사용하다보니 필요없는 함수가 많아졌다.\n그래서 기존에 있던 함수를 모두 주석처리하고 다시 만들면서 필요한 것들은 주석을 푸는 형식으로 고쳤다.\n\n이렇게 고치는 방식이 좋은 방식은 아니지만 블로그를 만들면서 너무 많은 계획과 실패를 반복하여 생긴 버릇인 것 같다.\n\n```typescript\n        /**\n         * 스크롤 이벤트를 헨들링해주는 함수입니다.\n         * \n         * @param event 스크롤 이벤트가 들어오는 매개변수입니다.\n         */\n        handleScroll(event:Event){\n            this.post.yPos = (event.target as HTMLElement).scrollTop\n\n            this.post.sections.forEach((section,index) => {\n                const htmlElement = section as HTMLElement\n                let top = (this.post.container as HTMLElement).scrollTop;\n                let offset = htmlElement.offsetTop - 150;\n                let height = htmlElement.offsetHeight;\n\n                if (top >= offset && top < offset + height){\n                    this.post.index = index\n                }\n            })\n\n            let bottom = (this.post.container as HTMLElement).scrollHeight - (this.post.container as HTMLElement).clientHeight - (this.post.yPos as number)\n\n            if(bottom == 0){\n                if(this.page.loading === this.page.current){\n                    \n                    if(this.page.current < this.page.total - 1){\n                        this.page.loading++\n                        this.settingTechView()\n                    }\n                }\n            }\n        },\n```\n\n이 코드가 나오기 까지 여러 과정을 거쳤는데 우선 ts혹은 js에 HTMLElement에 대한 scrollbottom의 항목이 없다는 것을 처음 알았다.\n\n그래서 `HTMLElement`의 `post.container(블로그 포스트를 저장하는 통)` 의 총 `scrollHeight`, `clientHeight`와\n\n`HTMLElement`의 `scrollTop` 현재 스크롤 높이 상황을 이용하는 것이다.\n\n즉 블로그 포스트가 많으면 포스트의 통이 늘어나는 것을 이용하는 것이다.\n\n`scrollHeight` - `clientHeight` - `scrollTop`으로 하면 scrollBottom이 나온다.\n\n이렇게 해서 스크롤 행동 감지를 통해 `scorllBottom`이 0에 도달하면 새로운 포스트를 불러오는 방식이다.\n\n그리고 함수가 많이 사용하지 않는 것들이랑 스파게티 코드처럼 필요없는 함수들과 줄일 수 있는 함수들을 많이 없앨 수 있는 기회가 되었다.\n\n그리고 현재 천천히 하고 있기는 하지만 그래도 절반 가까이 완성하였다. 이번 방학 전까지 tech 섹션에 있는 모든 것을 데스크톱, 태블렛, 안드로이드, ios까지\n완료할 것이고 차근차근이 현재 완성한 프로젝트와 하고 있는 프로젝트를 놓을 수 있는 섹션까지 완성할 것이다.\n\n이번에 대학교 성적이 나쁘지 않게 나와서 조기졸업이 가능할 것 같아서, 사실 이번 블로그 홈페이지를 업데이트하고 더 나갈 수 있을 지는 모르겠다.\n\n하지만 블로그 디자인과 추가가 아니더라도 우선 졸업 작품을 4학년 1학기 전까지 완성하고 싶어서 2학년 2학기 겨울방학부터 만들어 나갈 생각이다.\n\n자세한 내용은 기제하기 그래서 하진 않지만, 그래도 모르는 내용이 있으면 그 모르던 내용들을 기제하기 위해서 이 곳에 들어와서 기재할 것이다.\n","tags":["html","javascript","design","studying","vue","nodejs"],"dates":["2022-08-08T15:37:19Z","2022-08-08T15:12:18Z","2022-08-08T11:41:28Z","2022-08-08T11:39:47Z"]},{"id":"9","parent":"__SOURCE__","internal":{"type":"Post","contentDigest":""},"children":[],"title":"testingPurpose","content":"","dates":["2022-02-27T13:02:51Z","2022-02-27T13:01:14Z","2022-02-27T13:00:52Z","2022-02-24T15:49:16Z"]}]}